

1.  D > C > A > B

reason : 
   we try to use StringBuffer ,rather than String in java. when you change String ,it will create another String Object  . 
   StringBuffer has a capacity 16,if String lenth more 16  ,it will expand capacity .
   B has three varible ,it takes more reference .
   
   so the answer is D > C > A > B
   


2.

permanent generation : it's area for storing java class and method information .
new generation       :  new generation have eden and two survivors . 
                       while you 'new' object ,it will initial in eden . one of  survivors is empty.the other stores living object.
                       when gc running, it will copy  any live objects in eden and the other survivor space to the empty survivor , then the other will be clear
                       if the object living in den and one of survivors is old enought ,it will be copied to the old generation.
old generation       : it's the area for old living object waiting removed by gc 


3.
	public Boolean[] populateDataFlag(ResultSet rs) {
		try {
			if(rs == null || rs.isClosed()){
				//LOGGER
				return null;
			}
			List data = new ArrayList();
			while (rs.next()) {
				data.add(rs.getString("FLAG").equals("TRUE"));
			}
			return (Boolean[]) data.toArray(new Boolean[0]);
			
		} catch (Throwable t) {
			throw new Exception("LOGGER",t);
		} finally{
			try {
				if(rs != null){
					rs.close();
				}
			} catch (Exception e) {
				//LOGGER
			}
		}
	}

4.

   1.Generics  
    it makes precompile .
    one code can be used parameter with differet types .

   2.Enumerations
    Enumerations take place of many 'public static final XXXX ' ,
    Enumerations has it's method and is Comparable .


5.set  is collection , each elment in it is unique
  List is a kind of an ordered collection .the elements in it can be  duplicates.
  Map is a  key - value collection, and it's key is unique



6.  

  hashmap  it can have only one 'NULL' key.
  treemap is ordered map depend on red-black tree, it can not have 'NULL' key 
  linkedhashmap is double-linked map ,an have only one 'NULL' key.


7.

	public static Collection subtract(final Collection a, final Collection b) {
		Collection target = new ArrayList();
		for (Object aElement : a) {
			if(!b.contains(aElement)) target.add(aElement);
		}
		return target;
	}



8. use PreparedStatement to keep not SQL injection .

9. use SSL (for example  stunnel ) for socket connection.
   use https for web ,customize encryption

10.SELECT CSTM.CUST_ID AS CUST_ID,CSTM.CUST_NAME AS CUST_NAME ,CPLAN.PLAN_CODE AS PLAN_CODE  FROM CUSTOMER CSTM 
    LEFT JOIN CUST_PLAN CPLAN ON CSTM.CUST_ID = CPLAN.CUST_ID


11. SELECT DEPT_CODE,GRADE_CODE,STAFF_ID FROM staff WHERE DEPT_CODE IN (
                SELECT T.DEPT_CODE FROM (SELECT DEPT_CODE ,COUNT(*) AS STAFF_COUNT FROM staff GROUP BY DEPT_CODE) T WHERE T.STAFF_COUNT > 2 )



12.

function validateName(){

	if(!check()){
		document.getElementById("messageArea").innerHTML="<font color='red'>found illegal letter</font>";
	}

}

function check(){
	var name = document.getElementName("name")[0].value;
	var pattern =/^[A-Za-z]+$/ ;
	return pattern.test(name);
}




13.



编写自定义的ActionForm组件类

1. 继承org.apache.struts.action.ActionForm类

2. 利用struts框架所提供的HTML类型的标签相结合可以实现对客户端的表单数据的良好封装和支持；并且在用户自定义的ActionForm组件类中的各种成员属性的名称和数据类型必须要和请求页面表单中的各个字段相对应，目的是使得Struts框架的系统程序能够完成客户请求数据的自动化获取。

左图包含用户名userName和密码userPassword的一个Struts的页面表单，右图为与该表单相对应的ActionForm组件类中的userName和userPassword成员属性，两者保持了一致的命名映射规则。

另外，在ActionForm组件类中必须为各个成员属性提供setter和getter的数据访问方法。

如果满足这种要求，Struts框架会自动将客户端的请求填充在相应的ActionForm组件类中的各个成员属性中，最终实现ActionForm组件类和表示层组件之间的数据映射，而不再需要像传统的Web表单提交后需要在后台的程序中采用代码request.getParameter(“参数名称”);的方式来获取数据。

3.

另外，在ActionForm组件类中必须为各个成员属性提供setter和getter的数据访问方法。

如果满足这种要求，Struts框架会自动将客户端的请求填充在相应的ActionForm组件类中的各个成员属性中，最终实现ActionForm组件类和表示层组件之间的数据映射，而不再需要像传统的Web表单提交后需要在后台的程序中采用代码request.getParameter(“参数名称”);的方式来获取数据。





14 . I'm sorry . I didn't use IBM WebSphere before.


 


15.  

   if the application have a dataSource ,it should be singleton.

   
   



   if DataSource is not singleton,  everytime we got a connection will initialize  DataSource once....    It's terrible ! Sir







一般Singleton模式通常有几种种形式:

　　第一种形式:

　　定义一个类，它的构造函数为private的，它有一个static的private的该类变量，在类初始化时实例话，通过一个public的getInstance方法获取对它的引用,继而调用其中的方法。

　　public class Singleton {

　　private Singleton(){}

　　//在自己内部定义自己一个实例，是不是很奇怪？

　　//注意这是private 只供内部调用

　　private static Singleton instance = new Singleton();

　　//这里提供了一个供外部访问本class的静态方法，可以直接访问

　　public static Singleton getInstance() {

　　return instance;

　　}

　　}

　　第二种形式:

　　public class Singleton {

　　private static Singleton instance = null;

　　public static synchronized Singleton getInstance() {

　　//这个方法比上面有所改进，不用每次都进行生成对象，只是第一次

　　//使用时生成实例，提高了效率！

　　if (instance==null)

　　instance＝new Singleton();

　　return instance; }

　　}

　　例子：

　　/**

　　* 数据库连接管理类<br>

　　*/

　　public class DBManager {

　　private static Logger logger = Logger.getLogger(DBManager.class);

　　/**

　　* 本静态变量用来存放本系统启动时由Struts生成的连接池的数据源

　　*/

　　private static DataSource datasource;

　　/**

　　* 由于本类使用单态设计模式，因此不允许在使用中通过New进行实例化，那么本类就要提供一个 此类的实例供外界使用，这就是供外界使用的实例

　　*/

　　private static [color=#FF0000]DBManager dbConManager = new DBManager();[/color]//类被加载时构建实例

　　private DBManager() {

　　}

　　/**

　　* 此静态方法用来向类的静态变量赋值，用来在系统中使用 <br>

　　*

　　* @param mydatasource

　　*            传入的struts生成的数据源

　　*/

　　public void setDatasource(DataSource mydatasource) {

　　logger.info("设置数据源");

　　if (datasource == null) {

　　datasource = mydatasource;

　　}

　　}

　　/**

　　* 由于本类使用单态模式，不允许其他的类使用New进行创建实例 因此在这里提供一个共有的静态方法来向外界提供自己的一个实例。 <br>

　　*

　　* @return 返回本类的唯一实例

　　*/

　　public static DBManager getInstance() {

　　logger.info("获得数据库连接管理类的实例");

　　return dbConManager;



/**

　　* 此方法提供一个可用的数据库连接，从连接池中取得可用连接 <br>

　　*

　　* @return 可用的数据库连接

　　* @throws java.lang.SQLException

　　*             有可能要抛出的SQL异常

　　*/

　　public Connection getConnection() throws SQLException {

　　Connection conn = null;

　　try {

　　logger.info("从连接池中获得空闲的数据库连接");

　　conn = datasource.getConnection();

　　return conn;

　　} catch (SQLException ex) {

　　logger.error("DBManager.getConnection(获取数据库连接失败):[SQLException]"

　　+ ex.getMessage());

　　throw ex;

　　}

　　}

　　/**

　　* 这是一个用来关闭所有的数据库连接相关的打开对象的方法，这样作的好处是不用在每一次调用了sql之后 要写一大串的关闭操作。<br>

　　*

　　* @param conn

　　*            将要关闭的数据库连接

　　* @param st

　　*            将要关闭的数据库操作对象

　　* @param pst

　　*            将要关闭的预处理数据库操作对象

　　* @param cst

　　*            将要关闭的数据库存储过程调用对象

　　* @param rst

　　*            将要关闭的数据库记录集对象

　　* @throws java.lang.Exception

　　*             有可能要抛出的异常

　　*/

　　public void closeAll(Connection conn, Statement st, PreparedStatement pst,

　　CallableStatement cst, ResultSet rst) throws DBManagerException {

　　try {

　　if (rst != null) {

　　rst.close();

　　}

　　if (st != null) {

　　st.close();

　　}

　　if (pst != null) {

　　pst.close();

　　}

　　if (cst != null) {

　　cst.close();

　　}

　　if (conn != null) {

　　conn.close();

　　}

　　} catch (SQLException e) {

　　throw new DBManagerException("数据库对象关闭出错!"+e.getMessage(),e);

　　}

　　}
















16
  
   



